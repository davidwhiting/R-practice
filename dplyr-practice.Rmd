---
title: "R for Data Science"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## This is a tutorial I will expand upon while I practice using `dplyr`



```{r intro}
library("dplyr")
library("downloader")
url <- "https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/msleep_ggplot2.csv"
filename <- "msleep_ggplot2.csv"
```

```{r getdata}
if (!file.exists(filename)) download(url,filename)
msleep <- read.csv("msleep_ggplot2.csv")
head(msleep)
```

## Important `dplyr` verbs
These `dplyr` verbs are important to remember:

* `select()`
* `filter()`
* `arrange()`
* `mutate()`
* `summarise()`
* `group_by()`

| Verb | Description |
|:---|:---|
|`select()`| Choose columns |
| `filter()`| Choose rows |
| `arrange()`| Re-order or arrange |
| `mutate()`| Create new columns |
| `summarise()`| Summarise values |
| `group_by()`| Like SQL `group by`|

### Selecting columns using `select()`
Select the `name` and `sleep_total` columns:
```{r dplyr1}
sleepData <- select(msleep, name, sleep_total)
head(sleepData)
```
Select all but the `name` column
```{r dplyr2}
head(select(msleep, -name))
```
Select a range of columns using the `:` operator
```{r dplyr3}
head(select(msleep, name:order))
```

#### Other matching criteria

Select all columns starting with the string "sl" using the `starts_with()` function
```{r dplyr4}
head(select(msleep, starts_with("sl")))
```
Do something similar with `ends_with()`
```{r dplyr5}
head(select(msleep, ends_with("wt")))
```
`contains()`
```{r}
head(select(msleep, contains("_")))
```
`matches()` for regular expressions
```{r}
head(select(msleep, matches("*o[rn]*")))
```
or `one_of()`
```{r}
head(select(msleep, one_of(c("name", "order"))))
```

Note this last could also have been created by
```{r}
head(select(msleep, name, order))
```
And a programmatically almost useless `everything()`
```{r}
head(select(msleep, everything()))
```
However, I am told that `everything()` is used to rearrange the order of columns without having to write them all out:
```{r}
head(select(msleep, starts_with("sleep"),everything()))
```


## Selecting rows using `filter()`
In SQL parlance "SELECT columns FROM table WHERE condition" this is part of the WHERE statement
```{r}
filter(msleep, sleep_total >= 16)
```
We could also do this with the pipe operator `%>%` as
```{r}
msleep %>%
  filter(sleep_total >= 16) %>%
  head
```
or playing around with it more
```{r}
msleep %>%
  filter(sleep_total >= 16, bodywt >= 1) %>%
  filter(vore %in% c("omni", "insecti")) %>%
  head
```
or
```{r}
msleep %>%
  select(name, starts_with("sl")) %>%
  filter(sleep_total >= 16) %>%
  head
```
Note that filter can use the boolean operators `>=`, `>`, `<`, `<=`, `!=`, `==`, `%in%` to create the conditions

### Using `group_by()`
We can use the `group_by()` functionality with the `summarise()` to create new columns based on summary statistics
```{r}
msleep %>%
  group_by(order) %>%
  summarise(avg_sleep = mean(sleep_total),
            min_sleep = min(sleep_total),
            max_sleep = max(sleep_total),
            total = n())
```

More on `summarise()`:

`n()` returns the length of the vector, `first()` and `last()` return the first and last values in the vector, and `n_distinct()` is the number of distinct values in the vector.

Now putting everything together:
```{r}
msleep %>%
  group_by(order) %>%
  summarise(avg_sleep = mean(sleep_total),
            min_sleep = min(sleep_total),
            max_sleep = max(sleep_total),
            total = n()) %>%
  filter(total > 1) %>%
  arrange(desc(total), desc(avg_sleep))
```

## Data Transformations
## Joins
```{r}
library(tidyverse)
library(nycflights13)
```

The tables are
```{r}
airlines
airports
planes
weather
```
These tables are connected as follows:

* `tailnum` connects `planes` and `flights`
* `carrier` connects `airlines` and `flights`
* `flights` connects to `airports` via `origin` and `dest` variables
* `weather` connects to `flights` via `origin`, `year`, `month`, `day`, and `hour` 

Count the primary keys and check that they are indeed unique
```{r}
planes %>% 
  count(tailnum)
```
add the filter to check uniqueness
```{r}
planes %>% 
  count(tailnum) %>%
  filter(n>1)
```
Do the same for weather
```{r}
weather %>%
  count(year, month, day, hour, origin) %>%
  filter(n>1)
```

Some tables have complex primary keys
```{r}
flights %>%
  count(year, month, day, flight) %>%
  filter(n>1)
```
So the flight number is not unique, are there every any more than 2 flights?
```{r}
flights %>%
  count(year, month, day, flight) %>%
  filter(n>2) %>%
  arrange(desc(n))
```
So at least 2,729 flights have more than 2 (and up to 4) flights per day. Let's add `hour`
```{r}
flights %>%
  count(year, month, day, flight, hour) %>%
  filter(n>1) %>%
  arrange(desc(n))
```
Wow, that was not even sufficient! Let's add minute as well
```{r}
flights %>%
  count(year, month, day, flight, hour, minute) %>%
  filter(n>1)
```
What about `tailnum`?
```{r}
flights %>%
  count(year, month, day, flight, tailnum, hour, minute) %>%
  filter(n>1)
```
Finally, this appears like it would be sufficient to create a primary key. It would be easiest to construct a primary key after doing this complete grouping, or just do a primary key by row number:
```{r}
flights %>%
  mutate(primary_key = row_number()) %>%
  select(primary_key, everything())
```

### Joins
```{r}
flights2 <- flights %>%
  select(year:day, hour, origin, dest, tailnum, carrier)
flights2
```
Now left join to get the full airline name
```{r}
flights2 %>%
  select(-origin, -dest) %>%
  left_join(airlines, by="carrier")
```

An example of a more complex `by` statement is
```{r}
flights2 %>%
  left_join(airports, by=c("dest"="faa"))
```

## Dates and Times
Here we use the `lubridate` package to deal with dates and times
```{r}
library(tidyverse)

library(lubridate)
library(nycflights13)
```

And see if it's loaded correctly
```{r}
today()
now()
```

Now load a csv file
```{r}
mtcars <- read_csv(readr_example("mtcars.csv"))
```

Use `lubridate` to parse strings into date-times:
```{r}
ymd("2017-01-31")
mdy("January 31st, 2017")
dmy("31-Jan-2018")
```
They can also take unquoted numbers
```{r}
ymd(20180412)
```

To create date-times, add an underscore and `h`, `m`, `s` or any combination of them
```{r}
ymd_hms("2018-01-31 20:11:29")
mdy_hm("01/31/2018 08:01")
```

You can also supply a timezone
```{r}
ymd(2018-01-31, tz="UTC")
```

From individual flight components:
```{r}
flights %>%
  select(year, month,day, hour, minute)
```
```{r}
flights %>%
  select(year, month,day, hour, minute) %>%
  mutate(departure = make_datetime(year, month, day, hour, minute))
```
```{r}
make_datetime_100 <- function(year, month, day, time) {
  make_datetime(year, month, day, time %/% 100, time %% 100)
}

flights_dt <- flights %>% 
  filter(!is.na(dep_time), !is.na(arr_time)) %>% 
  mutate(
    dep_time = make_datetime_100(year, month, day, dep_time),
    arr_time = make_datetime_100(year, month, day, arr_time),
    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),
    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)
  ) %>% 
  select(origin, dest, ends_with("delay"), ends_with("time"))

flights_dt
```
Now visualize with ggplot
```{r}
flights_dt %>%
  ggplot(aes(dep_time)) +
  geom_freqpoly(binwidth = 86400)
```
or within a single day
```{r}
flights_dt %>% 
  filter(dep_time < ymd(20130102)) %>% 
  ggplot(aes(dep_time)) + 
  geom_freqpoly(binwidth = 600) # 600 s = 10 minutes
```
Switching between types:
```{r}
as_datetime(today())
as_date(now())
```
also as numeric offsets from the Unix Epoch
```{r}
as_datetime(60*60*10)
as_date(365*10 + 2)
```


